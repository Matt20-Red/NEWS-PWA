<!doctype html>
<html lang="ja">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="manifest" href="/manifest.json">
<title>bat</title>
<style>
  body{font-family:system-ui, sans-serif;max-width:640px;margin:24px auto;padding:0 12px}
  input,textarea,button{font:inherit;padding:8px;border-radius:8px;border:1px solid #ccc}
  textarea{width:100%;height:100px}
  .row{display:flex;gap:8px;margin:8px 0}
  .grow{flex:1}
</style>
<style>
  :root { color-scheme: dark; }
  html, body { background:#000; color:#fff; }
  input, textarea { background:#111; color:#fff; border:1px solid #333; border-radius:8px; padding:8px; }
  button { background:#222; color:#fff; border:1px solid #444; border-radius:10px; padding:8px 12px; cursor:pointer; }
  button:hover { background:#2a2a2a; }
  .row { display:flex; gap:8px; align-items:center; }
  .muted { color:#aaa; font-size:12px; }
  .hidden { display:none !important; }
  #inbox-section h2 { font-size:16px; margin:0; }
</style>
  
<body>
<h1 style="font-weight:600">bat</h1>

<div class="row">
  <input id="code" class="grow" placeholder="Code">
  <button id="btn-sub">Subscribe</button>
  <button id="btn-unsub">Unsubscribe</button>
</div>

<textarea id="message" placeholder="Message"></textarea>
<div class="row">
  <button id="btn-send" class="grow">Send</button>
</div>
  
<!-- ★ここに追加 -->
<button id="btn-local" class="hidden">ローカル通知テスト</button>
<button id="btn-self" class="hidden">自分にテスト送信</button>
<button id="btn-apple" class="hidden">Apple限定送信</button>
  
<pre id="log"></pre>

<section id="delivery" style="margin-top:12px;">
  <div class="row">
    <h2 style="font-size:16px;margin:0;">Last delivery</h2>
    <span id="delivery-meta" class="muted"></span>
  </div>
  <div id="delivery-result" class="muted">No recent delivery.</div>
</section>
  
<!-- 受信箱ビュー（コード別の最新K件を直読で描画） -->
<section id="inbox-section" style="margin-top:12px;">
  <div class="row" style="align-items:center;">
    <h2 style="margin:0; font-size:16px;">MessageBox（Local・Recent）</h2>
    <button id="inbox-refresh" style="margin-left:auto;">Update</button>
    <button id="inbox-pop-latest">OpenLatest</button>
  </div>
  <ul id="inbox-list" style="padding-left:18px; margin-top:8px;"></ul>
</section>
  
<script>
//const log = (...a)=>{ const p=document.getElementById('log'); p.textContent += a.join(' ') + '\n'; }
 // 重要なものだけ画面に出す（コンソールには全部流す）
  const LOG_ALLOW = /^(SW ready|SW登録OK|SW says: inbox-saved)/;
  const log = (...args) => {
    try {
      const txt = args.map(x => (typeof x==='string' ? x : JSON.stringify(x))).join(' ');
      if (LOG_ALLOW.test(txt)) {
        const pre = document.getElementById('log');
        if (pre) pre.textContent = txt + '\n' + pre.textContent;
      }
      console.log(...args);
    } catch {}
  };

  
// ★ SWは一度だけ登録
(async () => {
  if ('serviceWorker' in navigator) {
    try {
      const reg = await navigator.serviceWorker.register('/sw.js');
      console.log('SW registered scope:', reg.scope);
      log('SW登録OK scope:', reg.scope);
    } catch (e) {
      console.error('SW register failed:', e);
      log('SW登録失敗:', e?.message || e);
    }
  } else {
    log('SW非対応環境');
  }
})();

(async function main(){
  if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
    log('このブラウザはPush非対応です'); return;
  }

  // ★ ここでは register しない。ready を待つだけ。
  const reg = await navigator.serviceWorker.ready;
  log('SW ready');

  const VAPID_PUBLIC_KEY = 'BAV2ymIPqjBiWKHBUuklJIrJhr-Yk-8AXEzZp6RfbANML4W9XdQ4aqz-ZerM49qHvRn5l0VFUsVSXucnaQsTppI';

  const keyToUint8 = (base64url) => {
    const padding = '='.repeat((4 - base64url.length % 4) % 4);
    const base64 = (base64url + padding).replace(/-/g,'+').replace(/_/g,'/');
    const raw = atob(base64);
    const out = new Uint8Array(raw.length);
    for (let i=0;i<raw.length;i++) out[i] = raw.charCodeAt(i);
    return out;
  };

  async function getSub(){
    const existing = await reg.pushManager.getSubscription();
    if (existing) return existing;
    return reg.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: keyToUint8(VAPID_PUBLIC_KEY)
    });
  }

  document.getElementById('btn-sub').onclick = async () => {
    try {
      const code = document.getElementById('code').value.trim();
      if (!code) return alert('コードを入力');

      const perm = await Notification.requestPermission();
      log('通知許可ステータス:', perm);
      if (perm !== 'granted') { log('通知が許可されませんでした'); return; }

      const sub = await getSub();
      log('購読endpoint:', sub.endpoint.slice(0, 48) + '...');

      const r = await fetch('/api/subscribe', {
        method:'POST',headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ code, subscription: sub })
      });
      // log('subscribe status:', r.status);
      // const j = await r.json();
      // log('購読登録結果:', JSON.stringify(j));
      log('subscribe status:', r.status);
      if (!r.ok) {
        const t = await r.text();
        log('subscribe ERROR body:', t.slice(0,200));
        return;
      }
      const j = await r.json();
      log('購読登録結果:', JSON.stringify(j));
    } catch (e) {
      log('購読処理エラー:', e?.message || e);
    }
  };

  document.getElementById('btn-unsub').onclick = async () => {
    try {
      const code = document.getElementById('code').value.trim();
      if (!code) return alert('コードを入力');
      const sub = await reg.pushManager.getSubscription();
      if (!sub) return log('未購読です');

      await sub.unsubscribe().catch(()=>{});
      const r = await fetch('/api/unsubscribe', {
        method:'POST',headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ code, endpoint: sub.endpoint })
      });
      log('unsubscribe status:', r.status);
      const j = await r.json();
      log('購読解除結果:', JSON.stringify(j));
    } catch (e) {
      log('購読解除エラー:', e?.message || e);
    }
  };

  document.getElementById('btn-send').onclick = async () => {
    try {
      log('send click: handler start');  // ← クリック開始ログ
      const code = document.getElementById('code').value.trim();
      const message = document.getElementById('message').value;
      // if (!code || !message) return alert('コードとメッセージを入力');
      if (!code) { log('send stop: code empty'); alert('Enter Code'); return; }
      if (!message) { log('send stop: message empty'); alert('Enter Message'); return; }
      
      const r = await fetch('/api/broadcast', {
        method:'POST',headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ code, message })
      });
      // log('broadcast status:', r.status);
      console.log('broadcast status:', r.status);
      // const j = await r.json();
      // log('送信結果:', JSON.stringify(j));
      // console.log('送信結果:', j);
      // if (j.errors && j.errors.length) { log('エラー例:', j.errors[0].error); }
      if (!r.ok) {
        const t = await r.text();
        log('broadcast error body:', t.slice(0,400));
        return;
      }
      const j = await r.json().catch(e => ({ parseError: String(e) }));
      // log('送信結果:', JSON.stringify(j));
      
      updateDeliveryUI(true, j);
      // if (j?.errors?.length) { log('エラー例:', j.errors[0].error); }
      if (j?.errors?.length) { console.warn('error sample:', j.errors[0].error); }
    } catch (e) {
      log('送信時エラー:', e?.message || e);
    }
  };

  document.getElementById('btn-local').onclick = async () => {
    const reg = await navigator.serviceWorker.ready;
    await reg.showNotification('通知(ローカル)', {
      body: 'SW.showNotification からのテスト',
      icon: '/icon-192.png',   // 必要なら manifest のアイコンに合わせる
      badge: '/icon-192.png',
      data: { url: '/' },
    });
    log('local notification requested');
  };

  document.getElementById('btn-self').onclick = async () => {
  try {
    log('self-send: start');
    const reg = await navigator.serviceWorker.ready;
    let sub = await reg.pushManager.getSubscription();
    if (!sub) {
      alert('Please Subscribe'); return;
    }
    const r = await fetch('/api/push-one', {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ message: 'self test', subscription: sub })
    });
    log('self-send status:', r.status);
    const t = await r.text();
    log('self-send body:', t.slice(0,300));
  } catch (e) {
    log('self-send error:', e?.message || e);
  }
  };

document.getElementById('btn-apple').onclick = async () => {
  const code = document.getElementById('code').value.trim();
  const message = document.getElementById('message').value || 'apple only';
  if (!code) return alert('Enter Code');
  const r = await fetch('/api/broadcast-apple', {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ code, message })
  });
  log('apple-only status:', r.status);
  log('apple-only body:', (await r.text()).slice(0,400));
};
  
})();

// ==== Caches 直読ユーティリティ（受信箱の非同期描画） ====
// SW と同じキーで読みに行く（読み取り専用）
const INBOX_CACHE = 'inbox-cache-v1';
const INBOX_KEY = (code) => '/__inbox/' + encodeURIComponent(code);

// TTL/件数の整形（SWの prune と同等の軽実装）
function pruneList(items, ttlMs = 3*60*60*1000, maxItems = 5) {
  const now = Date.now();
  const a = (Array.isArray(items) ? items : []).filter(it => !it?.ts || (now - it.ts) <= ttlMs);
  return a.slice(0, maxItems); // 先頭が新しい前提（SW側でunshift保存）
}

// Caches 直読して一覧を返す（非破壊）
async function readInboxDirect(code, { ttlMs = 3*60*60*1000, maxItems = 5 } = {}) {
  try {
    const cache = await caches.open(INBOX_CACHE);
    const res = await cache.match(INBOX_KEY(code));
    if (!res) return [];
    const list = await res.json();
    return pruneList(list, ttlMs, maxItems);
  } catch (e) {
    log('inbox read error:', e?.message || e); 
    return [];
  }
}

// 受信箱の描画
async function renderInbox() {
  const code = currentCode();
  const ul = document.getElementById('inbox-list');
  ul.innerHTML = '';
  if (!code) { ul.innerHTML = '<li>*Please enter the code</li>'; return; }

  log('[inbox] refresh start');
  const items = await readInboxDirect(code);
  if (!items.length) {
    ul.innerHTML = '<li>（No Unread Message）</li>';
    log('[inbox] empty');
    return;
  }
  for (const it of items) {
    const li = document.createElement('li');
    const when = new Date(it.ts || Date.now()).toLocaleString();
    li.textContent = `${when}: ${it.body || '(no body)'}`;
    ul.appendChild(li);
  }
  log(`[inbox] render ${items.length} item(s)`);
}

// UIボタン：更新／最新を開く（= 消費して in-app 表示）
document.getElementById('inbox-refresh')?.addEventListener('click', renderInbox);
document.getElementById('inbox-pop-latest')?.addEventListener('click', () => {
  const code = currentCode();
  if (!code) return alert('Enter Code');
  // 最新1件を consume で取得 → showInApp
  const ctrl = navigator.serviceWorker && navigator.serviceWorker.controller;
  if (!ctrl) return;
  const onMsg = (e) => {
    const m = e.data || {};
    if (m.__inbox && m.code === code) {
      navigator.serviceWorker.removeEventListener('message', onMsg);
      if (m.data) {
        log('[inbox] pop latest -> in-app');
        showInApp({ title: m.data.title || '通知', body: m.data.body || '', url: m.data.url || '/' });
        // consume したのでUI再描画
        renderInbox();
      } else {
        log('[inbox] pop latest -> empty');
        alert('未読はありません');
      }
    }
  };
  navigator.serviceWorker.addEventListener('message', onMsg);
  try { ctrl.postMessage({ __req_inbox: true, code, consume: true, ttlMs: 3*60*60*1000 }); } catch {}
});

// 初回オート描画
renderInbox();

</script>


<script>
/*
if (navigator.serviceWorker) {
  navigator.serviceWorker.addEventListener('message', (e) => {
    if (m.__inbox) handleInboxData(m);
    const m = e.data || {};
    if (m.__debug === 'push-received') {
      log('SW says: push-received', JSON.stringify({ title: m.title, hasBody: !!m.body, url: m.url }));
    }
    // __open が届いたら上書き遷移（null は無視）
    if (Object.prototype.hasOwnProperty.call(m, '__open')) {
      if (m.__open) {
        try { location.replace(m.__open); } catch {}
      }
    }
  });
}
*/

// --- SW からのメッセージ受信（統合版） ---
if (navigator.serviceWorker) {
  navigator.serviceWorker.addEventListener('message', (e) => {
    const m = e.data || {};

    // 1) inbox（前面化回収で届く最新1件）
    if (m.__inbox) {
      handleInboxData(m);
      return; // 早期リターンで以降の分岐と競合しないように
    }

    // 2) デバッグ（受信確認）
    if (m.__debug === 'push-received') {
      log('SW says: push-received', JSON.stringify({ title: m.title, hasBody: !!m.body, url: m.url }));
      log('SW says: inbox-saved', JSON.stringify({ code: m.code, count: m.count }));
    }

    // 3) 旧E対策の __open（フォールバック経路）
    if (Object.prototype.hasOwnProperty.call(m, '__open')) {
      if (isAutoOpenSuppressed()) return; // ← 抑止中は /note へ飛ばない
      if (m.__open) {
        try { location.replace(m.__open); } catch {}
      }
    }

    // 4) in-app の __intent（受け取れたらACKを返す）
    if (m.__intent) {
      showInApp(m.__intent);
      const ctrl = navigator.serviceWorker && navigator.serviceWorker.controller;
      if (ctrl && m.__intent.id) {
        try { ctrl.postMessage({ __intent_ack: true, id: m.__intent.id }); } catch {}
      }
    }
  });
}

  
/* BroadcastChannel でも受け取って上書き遷移 */
try {
  const bc = new BroadcastChannel('sw-bridge');
  bc.onmessage = (e) => {
    const m = e.data || {};
    if (m.__open) {
      try { location.replace(m.__open); } catch {}
    }
  };
} catch {}

  
/* 前面化したら SW に「最後のURLある？」と問い合わせ */
function requestLastOpen() {
   if (isAutoOpenSuppressed()) return; // ← 抑止中は問い合わせ自体しない
  const ctrl = navigator.serviceWorker && navigator.serviceWorker.controller;
  if (ctrl) {
    try { ctrl.postMessage({ __req_open: true }); } catch {}
  }
}
document.addEventListener('visibilitychange', () => {
  log('[vis] visibilitychange hidden=', document.hidden, 'suppress=', isAutoOpenSuppressed());
  if (!document.hidden) setTimeout(requestLastOpen, 0);
});
window.addEventListener('pageshow', () => {
  log('[vis] pageshow suppress=', isAutoOpenSuppressed());
  setTimeout(requestLastOpen, 0);
});
window.addEventListener('focus', () => {
  log('[vis] focus suppress=', isAutoOpenSuppressed());
  setTimeout(requestLastOpen, 0);
});
  
// ===== In-App 表示：ユーティリティ =====
let __lastHandledTs = 0;
function showInApp(intent) {
  try {
    if (!intent || !intent.body) return;
    const ts = Number(intent.ts || 0);
    if (ts && ts <= __lastHandledTs) return; // 同じメッセージの二重処理防止
    __lastHandledTs = ts || Date.now();

    // 本文反映
    document.getElementById('inapp-body').textContent = String(intent.body || '');

    // /note.html へ渡す（クエリ化）の補助リンク
    const url = intent.url || (`/note.html?ts=${Date.now()}&m=${encodeURIComponent(String(intent.body||''))}`);
    const a = document.getElementById('inapp-open-note');
    a.href = url;

    // 表示
    document.getElementById('inapp').style.display = 'block';
  } catch {}
}
(function bindInAppButtons(){
  const hide = () => { document.getElementById('inapp').style.display = 'none'; };
  document.getElementById('inapp-close').onclick = hide;
  document.getElementById('inapp-back').onclick = hide;
})();

/*
// ===== 既存SWリスナーに “intent” 受信を追加 =====
if (navigator.serviceWorker) {
  navigator.serviceWorker.addEventListener('message', (e) => {
    const m = e.data || {};
    // 既存：__debug / __open の処理はそのまま
    // if (m.__intent) showInApp(m.__intent);
      if (m.__intent) {
        showInApp(m.__intent);
        // ★ SWにACKを返す（手元で受け取れた合図）
        const ctrl = navigator.serviceWorker && navigator.serviceWorker.controller;
        if (ctrl && m.__intent.id) {
          try { ctrl.postMessage({ __intent_ack: true, id: m.__intent.id }); } catch {}
        }
      }
  });
}
*/
  
// ===== BroadcastChannel でも intent を受ける =====
try {
  const bc = new BroadcastChannel('sw-bridge');
  bc.onmessage = (e) => {
    const m = e.data || {};
    if (m.__intent) showInApp(m.__intent);
      const ctrl = navigator.serviceWorker && navigator.serviceWorker.controller;
      if (ctrl && m.__intent && m.__intent.id) {
        try { ctrl.postMessage({ __intent_ack: true, id: m.__intent.id }); } catch {}
      }
  };
} catch {}


// ===== 前面化で “遅延回収”：SWへ intent 問い合わせ =====
function requestLastIntent() {
  const ctrl = navigator.serviceWorker && navigator.serviceWorker.controller;
  if (ctrl) { try { ctrl.postMessage({ __req_intent: true }); } catch {} }
}
// 既存の requestLastOpen() があれば併存OK（上書きしません）
/*
document.addEventListener('visibilitychange', () => { if (!document.hidden) setTimeout(requestLastIntent, 0); });
window.addEventListener('pageshow', () => setTimeout(requestLastIntent, 0));
window.addEventListener('focus', () => setTimeout(requestLastIntent, 0));
*/

function pollLastIntentBriefly() {
  let tries = 0, maxTries = 12;
  (async function loop(){
    if (isAutoOpenSuppressed()) return; // ← 抑止中は自動回収を止める
    // in-app が既に開いているなら打ち切り
    const inappVisible = document.getElementById('inapp')?.style.display !== 'none';
    if (inappVisible) return;

    requestLastIntent();
    tries++;
    if (tries < maxTries) {
      await new Promise(r => setTimeout(r, 250));
      loop();
    }
  })();
}

document.addEventListener('visibilitychange', () => {
//  if (!document.hidden) pollLastIntentBriefly();
if (!document.hidden && !isAutoOpenSuppressed()) { pollLastIntentBriefly(); }
});
window.addEventListener('pageshow', () => {
  // pollLastIntentBriefly());
if (!isAutoOpenSuppressed()) { pollLastIntentBriefly(); }
});
window.addEventListener('focus', () => {
  // pollLastIntentBriefly());
if (!isAutoOpenSuppressed()) { pollLastIntentBriefly(); }
});
  
// 共有コードを入力欄から取得（あなたのUIに合わせて）
function currentCode() {
  const el = document.getElementById('code');
  return el ? (el.value || '').trim() : '';
}

function pollInboxBriefly() {
  let tries = 0, max = 8;
  (async function loop(){
    // if (isAutoOpenSuppressed()) return; // ← 抑止中は自動回収を止める
    log('[inbox] tick', tries);
    const code = currentCode();
    if (code) {
      log('[inbox] requestInbox consume=false', code);
      requestInbox(code, { consume: true }); // 最新1件を取りに行く
    }
    tries++;
    if (tries < max) { await new Promise(r => setTimeout(r, 250)); loop(); }
  })();
}

// 既存の前面化フックに “受信箱回収” を足す
document.addEventListener('visibilitychange', () => {
  // if (!document.hidden) pollInboxBriefly(); 
  if (!document.hidden) { pollInboxBriefly(); }
});
window.addEventListener('pageshow', () => {
  // pollInboxBriefly());
  { pollInboxBriefly(); }
});
window.addEventListener('focus', () => {
  // pollInboxBriefly());
  { pollInboxBriefly(); }
});
  
// === 受信箱・回収 ===
function requestInbox(code, { consume = true, ttlMs = 3*60*60*1000 } = {}) {
  const ctrl = navigator.serviceWorker && navigator.serviceWorker.controller;
  if (!ctrl || !code) return;
  try { ctrl.postMessage({ __req_inbox: true, code, consume, ttlMs }); } catch {}
}

// SWから受け取った受信箱データを in-app で表示
function handleInboxData(msg) {
  log('[inbox] handle', !!msg?.data);
  if (!msg || !msg.__inbox) return;
  const data = msg.data;
  if (!data) return; // 未読なし
  // data は1件（consume:true）
  showInApp({
    title: data.title || '通知',
    body: data.body || '',
    url:  data.url || '/'
  });
}

function suppressAutoOpen(ms = 3000) {
  try { sessionStorage.setItem('suppressAutoOpenUntil', String(Date.now() + ms)); } catch {}
}
function isAutoOpenSuppressed() {
  try { return Date.now() < (+sessionStorage.getItem('suppressAutoOpenUntil') || 0); } catch { return false; }
}

async function updateDeliveryUI(ok, json) {
  const box = document.getElementById('delivery-result');
  const meta = document.getElementById('delivery-meta');
  if (!box) return;
  if (!ok || !json) {
    box.textContent = 'Failed to deliver.';
    if (meta) meta.textContent = new Date().toLocaleString();
    log('broadcast result failed');
    return;
  }
  const { attempted=0, accepted=0, expired=0, retry=0, remaining=0, skipped=0, removed } = json;
  const removedCount = Array.isArray(removed) ? removed.length : 0;
  box.textContent = `Attempted ${attempted}, Accepted ${accepted}, Expired ${expired}, Retry ${retry}, Removed ${removedCount}, Remaining ${remaining}, Skipped ${skipped}`;
  if (meta) meta.textContent = new Date().toLocaleString();
  log('broadcast result', box.textContent);
}
  
</script>

<!-- In-App メッセージビュー（モーダル） -->
<div id="inapp" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.35); z-index:9999;">
  <!-- <div style="background:#fff; max-width:720px; margin:10vh auto; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.2); padding:16px;"> -->
  <div style="background:#111; color:#fff; max-width:720px; margin:10vh auto; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.5); padding:16px; border:1px solid #333;">
  <div style="display:flex; align-items:center; justify-content:space-between;">
      <h2 style="margin:0; font-size:18px;">Incoming Message</h2>
      <button id="inapp-close" style="border:none; background:transparent; font-size:18px; cursor:pointer;">✕</button>
    </div>
    <!-- <pre id="inapp-body" style="white-space:pre-wrap; word-break:break-word; margin-top:12px; background:#f6f6f6; padding:12px; border-radius:8px;"></pre> -->
    <pre id="inapp-body" style="white-space:pre-wrap; word-break:break-word; margin-top:12px; background:#111; color:#fff; border:1px solid #333; padding:12px; border-radius:8px;"></pre>
    <div style="margin-top:12px; display:flex; gap:8px;">
      <!-- 任意：/note.htmlで開きたい人向けのリンク（痕跡は note 側で消える） -->
      <!-- <a id="inapp-open-note" href="#" style="text-decoration:none; padding:8px 12px; border-radius:8px; background:#eee;">Open in full view</a> -->
      <a id="inapp-open-note" href="#" style="text-decoration:none; padding:8px 12px; border-radius:8px; background:#222; color:#fff; border:1px solid #444;">Open in full view</a>
      <!--<button id="inapp-back" style="padding:8px 12px; border-radius:8px; border:1px solid #ddd; background:#fff; cursor:pointer;">戻る</button> -->
    </div>
  </div>
</div>
  
</body>
</html>
